package com.webcon.sus.activities;

import android.app.AlertDialog;
import android.app.ProgressDialog;
import android.content.Context;
import android.content.DialogInterface;
import android.content.Intent;
import android.content.pm.ActivityInfo;
import android.graphics.Color;
import android.os.Bundle;
import android.os.Handler;
import android.os.Message;
import android.support.annotation.NonNull;
import android.util.Log;
import android.view.KeyEvent;
import android.view.MotionEvent;
import android.view.SurfaceHolder;
import android.view.SurfaceView;
import android.view.View;
import android.view.WindowManager;
import android.widget.ImageButton;

import com.hikvision.netsdk.HCNetSDK;
import com.webcon.sus.demo.R;
import com.webcon.sus.entity.BaseDevice;
import com.webcon.sus.entity.MonitorNode;
import com.webcon.sus.entity.StationNode;
import com.webcon.sus.eventObjects.MonitorEvent;
import com.webcon.sus.utils.AudioUtils;
import com.webcon.sus.utils.CommunicationUtils;
import com.webcon.sus.utils.IVideoCallback;
import com.webcon.wp.utils.ApplicationManager;
import com.webcon.wp.utils.PublicMethodUtil;
import com.webcon.wp.utils.WPApplication;

import org.MediaPlayer.PlayM4.Player;

import java.util.Timer;
import java.util.TimerTask;

import de.greenrobot.event.EventBus;
import vieboo.test.record.utils.IRecordData;

/**
 * @author m
 */
public class MonitorActivityCompat extends BaseActivity implements View.OnClickListener,
        View.OnTouchListener,IRecordData, IVideoCallback, SurfaceHolder.Callback{

    private static final String TAG = "Mornitor";
    private static final int WAITING_TIME = 10000;   //20000
    private static int mPlayerPort = 0;

    private Context mContext;
    private int stationId;
    private String deviceId;
    private MonitorNode mDevice;

    private Player mPlayer;
    private AudioUtils mAudioUtils;

    private SurfaceView mSurfaceView;
    private ImageButton bn_quit;
    private ProgressDialog mLoading;
    private Timer mTimer;
    private RequestFailedTask requestFailedTask;

    /* ----------------- */
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        initData(getIntent());
        initView();
    }

    private void initData(Intent intent){
        Bundle bundle = intent.getExtras();
        if(bundle == null){
            errorQuit(1001);
            finish();
        }else{
            stationId = bundle.getInt(MainStationListFragment.KEY_ID, -1);
            deviceId = bundle.getString(StationDevicesFragment.KEY_DEVICE, "");
            if(stationId == -1 || deviceId.equals("")){
                errorQuit(1002);
                finish();
            }else if(stationId != WPApplication.getInstance().getStationNode(stationId).getIdentifier()){
                errorQuit(1003);
                finish();
            }
        }
        StationNode node = WPApplication.getInstance().getStationNode(stationId);
        if(node != null){
            for(BaseDevice n : node.getDeviceList()){
                if(n.getID().equals(deviceId)){
                    if(n instanceof MonitorNode){
                        mDevice = (MonitorNode) n;
                    }else{
                        errorQuit(6001);
                        finish();
                    }
                    break;
                }
            }
        }
//        try {
//            byte[] deviceIdUtf = (deviceId + "\0").getBytes(WPConstant.STRING_UTF8);
//        } catch (UnsupportedEncodingException e) {
//            e.printStackTrace();
//        }
        EventBus.getDefault().register(this);
    }

    private void initView() {
        // 强制切换成横屏
        if (getRequestedOrientation() != ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE) {
            setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
        }
        // 全屏显示
        getWindow().setFlags(WindowManager.LayoutParams.FLAG_FULLSCREEN, WindowManager.LayoutParams.FLAG_FULLSCREEN);
        getWindow().addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON);   //保持屏幕常亮FLAG
        mContext = this;
        setContentView(R.layout.layout_monitor_compat);
        //FIXME: ##添加到全局Application管理，便于退出?
        ApplicationManager.getInstance().addActivity(this);
        mSurfaceView = (SurfaceView) findViewById(R.id.monitor_surface);
        mSurfaceView.getHolder().addCallback(this);
        //退出按钮
        bn_quit = (ImageButton) findViewById(R.id.monitor_quit);
        bn_quit.setOnClickListener(this);
        //加载等待对话框
        mLoading = PublicMethodUtil.getInstance().makeProgressDialog(
                mContext, R.string.str_null, R.string.str_monitoringvideo_loading_loadvideo, false, true,
                new DialogInterface.OnKeyListener() {
                    @Override
                    public boolean onKey(DialogInterface dialog, int keyCode, KeyEvent event) {
                        if(event.getAction() == KeyEvent.ACTION_DOWN && keyCode == KeyEvent.KEYCODE_BACK){
                            quit(0);
                            return true;
                        }else{
                            return false;
                        }
                    }
                }
        );
        mLoading.setCanceledOnTouchOutside(false);
        showLoading();
        // 请求视频20s(10)后无数据关闭当前请求页面
        mTimer = new Timer();
        requestFailedTask = new RequestFailedTask();
        mTimer.schedule(requestFailedTask, WAITING_TIME);
        //录音工具
        mAudioUtils = new AudioUtils(this);
    }


    /**
     * 初始化播放库
     */
    private boolean initPlayerSDK() {
        mPlayer = Player.getInstance();
        if (mPlayer == null) {
            quit(-3);
            return false;
        }
        mPlayerPort = mPlayer.getPort();
        if (!mPlayer.setStreamOpenMode(mPlayerPort, Player.STREAM_REALTIME)) {
            quit(-3);
            return false;
        }
        return true;
    }

    /**
     * 监控视频页面的Handler
     * <p>用于关闭dialog、以及显示错误原因</p>
     */
    Handler monitorVideoHandler = new Handler() {

        @Override
        public void handleMessage(Message msg) {
            closeLoading();
            switch (msg.what) {
                case 10:
                    break;
                case -1:
                    showToast(mContext, R.string.str_monitoringvideo_toast_loadvideofaild);
                    break;
                case -2:
                    showToast(mContext, R.string.str_monitoringvideo_toast_flowused_f);
                    break;
                case -3:
                    showToast(mContext, R.string.str_monitoringvideo_toast_flowused_g);
                    break;
                case -4:
                    showToast(mContext, R.string.str_monitoringvideo_toast_flowused_h);
                default:
                    break;
            }
        }
    };

    @Override
    public void releaseHandler(){
        monitorVideoHandler.removeCallbacksAndMessages(null);
        monitorVideoHandler = null;
    }

    /**
     * 开启Loading对话框
     */
    private void showLoading(){
        if(mLoading != null && !mLoading.isShowing()){
            mLoading.show();
        }
    }

    /**
     * 退出处理
     * <p>主要包括关闭Loading的处理</p>
     */
    private void quit(int what){
        monitorVideoHandler.sendEmptyMessage(what);
        quit();
    }

    /**
     * 退出处理
     * <p>主要是释放资源、清理线程、发送关闭请求等，不涉及UI处理</p>
     */
    private synchronized void quit() {
        clearTimer();
        release();
        // 向监控端发送停止视频请求
        new Thread(new RequestStopPreviewRunnable()).start();
        finish();
    }

    /**
     * 关闭Loading对话框
     */
    private void closeLoading() {
        if (mLoading != null) {
            if(mLoading.isShowing()){
                mLoading.dismiss();
                mLoading.cancel();
            }
            mLoading = null;
        }
    }

    /**
     * 资源释放
     */
    private void release() {
        if(mPlayer != null){
            mPlayer.stop(mPlayerPort);
            mPlayer.closeStream(mPlayerPort);
            mPlayer.freePort(mPlayerPort);
            mPlayer = null;
        }

        mAudioUtils.release();
        EventBus.getDefault().unregister(this);
        CommunicationUtils.getInstance().unregisterVideoCallback();
    }

    /**
     * 清理计时器
     */
    private void clearTimer(){
        if(mTimer != null){
            mTimer.purge();
            mTimer.cancel();
            mTimer = null;
        }
    }

    /* --------------------- surface view ----------------------- */
    /* onCreate -> onResume -> surfaceCreated */
    @Override
    public void surfaceCreated(SurfaceHolder holder) {
        //初始化播放库
        initPlayerSDK();
        //向通信库注册回调监听，用于回调视频数据 ##FIXME：通信库方面需要具体考虑
        CommunicationUtils.getInstance().registerVideoCallback(this);
        //发送预览请求
        new Thread(new RequestPreviewRunnable()).start();
    }

    @Override
    public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
    }

    @Override
    public void surfaceDestroyed(SurfaceHolder holder) {
    }


    /* ------------------- 回调什么的... ------------------------- */
    @Override
    public boolean onKeyDown(int keyCode, @NonNull KeyEvent event) {
        if (event.getAction() == KeyEvent.ACTION_DOWN && keyCode == KeyEvent.KEYCODE_BACK) {
            quit(0);
        }
        return super.onKeyDown(keyCode, event);
    }


    @Override
    public boolean onTouch(View v, MotionEvent event) {
        return false;
    }

    @Override
    public void onClick(View v) {
        // 退出按钮//语音//云台控制
        if(v == bn_quit){
            //loading显示的时候也点击不了，就不处理loading了
            quit();
        }
    }

    //语音回调：本地工具->接口->发送
    @Override
    public void onRecordData(byte[] data, int length){
        CommunicationUtils.getInstance().sendVoice(stationId, deviceId, data, length);
    }

    @Override
    public void onData(int iRealHandle, int iDataType, byte[] pDataBuffer, int iDataSize) {
        //FIXME：也可能不是按数据类型区分
        switch (iDataType){
            //系统头
            case HCNetSDK.NET_DVR_SYSHEAD:
                //清除等待计时器
                clearTimer();
                if(iDataSize > 0){
                    mPlayer.openStream(mPlayerPort, pDataBuffer, iDataSize, 1024 * 800);
                    mPlayer.setDisplayBuf(mPlayerPort, 15);
                    mPlayer.play(mPlayerPort, mSurfaceView.getHolder());
                    break;
                }
                // 发送一个msg通知UI线程关闭Progressdialog
                monitorVideoHandler.sendEmptyMessage(10);
                break;
            case HCNetSDK.NET_DVR_STREAMDATA: //码流数据
                if(iDataSize > 0 && iRealHandle != -1){
                    if(!mPlayer.inputData(mPlayerPort, pDataBuffer, iDataSize)){
                        break;
                    }
                }
                break;
            default:
                break;
        }
    }

    public void onEventMainThread(MonitorEvent event){
        //TODO: ##设备掉线、用户被挤下线
        switch (event.getType()){
            case MonitorEvent.MONITOR_EXCEPTION_QUIT:
                mSurfaceView.setBackgroundColor(Color.BLACK);
                quit();//不知道具体情况，loading怎么办？
                break;
            case MonitorEvent.MONITOR_EXCEPTION_LINE:
                AlertDialog.Builder builder = new AlertDialog.Builder(mContext);
                builder.setTitle("警告");
                builder.setMessage("设备网络异常，请稍后重新预览！");
                builder.setPositiveButton("退出",
                        new DialogInterface.OnClickListener() {
                            @Override
                            public void onClick(DialogInterface dialog, int which) {
                                quit();
                            }
                        });
                builder.create().show();
                break;
            default:
                break;
        }
    }

    /* ------------------ Thread ---------------------------- */
    /**
     * 请求监控设备的视频
     */
    private class RequestPreviewRunnable implements Runnable {
        // 注：之前是由MonitorUser创建P2P连接，再发送请求
        // 这里直接连接。。。
        @Override
        public void run() {
            try {
                Thread.sleep(200);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            if(CommunicationUtils.getInstance().openMonitorPreview(stationId, deviceId) < 0){
                quit(-4);
            }
        }
    }


    /**
     * 向监控用户发送停止视频的请求
     */
    private class RequestStopPreviewRunnable implements Runnable {
        @Override
        public void run() {
            int cancelVideoResult = -1;
            int numFlag = 0; // 请求5次失败后停止请求
            while (cancelVideoResult != 0 && numFlag++ < 5) {
                Log.i(TAG, "request stop");
                cancelVideoResult = CommunicationUtils.getInstance().closeMonitorPreview(stationId, deviceId);
            }
        }
    }

    /**
     * 请求视频失败(超时)，退出当前页面
     */
    private class RequestFailedTask extends TimerTask {
        @Override
        public void run() {
            quit(-2);
        }
    }

}
